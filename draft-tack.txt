


TLS Working Group                                         M. Marlinspike
Internet-Draft                                            T. Perrin, Ed.
Intended status: Standards Track                          April 10, 2012
Expires: October 12, 2012


                 Trust Assertions for Certificate Keys
                             draft-tack.txt

Abstract

   This document defines TACK, a TLS Extension that enables a TLS server
   to assert the authenticity of its public key.  A TACK contains a
   "TACK signing key" and a corresponding "TACK signature" over the
   public key from the TLS server's certificate.  Hostnames can be
   "pinned" to a TACK key.  TLS connections to a pinnned hostname are
   only considered verified if the server presents a valid signature
   from the pinned key.

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on October 12, 2012.

Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of



Marlinspike & Perrin    Expires October 12, 2012                [Page 1]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Requirements notation  . . . . . . . . . . . . . . . . . . . .  4
   3.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
     3.1.  TACK life cycle  . . . . . . . . . . . . . . . . . . . . .  5
     3.2.  Pin life cycle . . . . . . . . . . . . . . . . . . . . . .  6
   4.  TACK Extension . . . . . . . . . . . . . . . . . . . . . . . .  7
     4.1.  Definition of TACK_Extension . . . . . . . . . . . . . . .  7
     4.2.  Explanation of TACK_Extension fields . . . . . . . . . . .  8
       4.2.1.  TACK_Key fields  . . . . . . . . . . . . . . . . . . .  8
       4.2.2.  TACK fields  . . . . . . . . . . . . . . . . . . . . .  8
       4.2.3.  TACK_Break_Sig fields  . . . . . . . . . . . . . . . .  9
       4.2.4.  TACK_Extension fields  . . . . . . . . . . . . . . . .  9
   5.  Client processing  . . . . . . . . . . . . . . . . . . . . . . 10
     5.1.  TACK pins, key records, and host records . . . . . . . . . 10
     5.2.  High-level client processing . . . . . . . . . . . . . . . 10
     5.3.  Client processing details  . . . . . . . . . . . . . . . . 11
       5.3.1.  Discarding pins based on break signatures  . . . . . . 11
       5.3.2.  Checking for a valid TACK  . . . . . . . . . . . . . . 11
       5.3.3.  Updating and activating pins based on the TACK . . . . 12
   6.  TACK IDs . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
   7.  Advice . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
     7.1.  For server operators . . . . . . . . . . . . . . . . . . . 14
     7.2.  For client implementors  . . . . . . . . . . . . . . . . . 15
   8.  Security considerations  . . . . . . . . . . . . . . . . . . . 16
   9.  IANA considerations  . . . . . . . . . . . . . . . . . . . . . 17
     9.1.  New entry for the TLS ExtensionType Registry . . . . . . . 17
     9.2.  New registry for TACK_Version  . . . . . . . . . . . . . . 17
   10. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 18
   11. Normative references . . . . . . . . . . . . . . . . . . . . . 19
   Appendix A.  Implementing the TACK ID alphabet . . . . . . . . . . 20
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 21














Marlinspike & Perrin    Expires October 12, 2012                [Page 2]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


1.  Introduction

   Traditionally, a TLS client verifies a TLS server's public key using
   a certificate chain issued by some public CA.  TACK facilitates
   stronger methods of verifying server public keys.

   One such method is for clients to employ "pinning", in which the
   client uses past connections to verify future connections by checking
   for some constant element.  Unfortunately, a number of problems arise
   when attempting to pin certificate chains: the TLS servers at a given
   hostname may have different certificate chains and may change their
   chains at any time; the "more constant" elements of a chain - the CAs
   - may not be trustworthy; and the client may be oblivious to key
   compromise events which render the pinned data untrustworthy.

   TACK addresses these problems by having the site sign its TLS server
   public keys with a "TACK key".  This enables clients to "pin" a
   hostname to the TACK key without requiring sites to modify their
   existing certificate chains, and without limiting a site's
   flexibility to deploy different certificate chains on different
   servers or change certificate chains at any time.  Since TACK pins
   are based on TACK keys (instead of CA keys), trust in CAs is not
   required.  Additionally, the TACK key may be used to revoke previous
   TACK signatures or even itself, to handle compromise of TLS or TACK
   private keys.

   If requested, a compliant server will send a TLS Extension containing
   its "TACK".  Inside the TACK is a TACK public key and TACK signature.
   Once a client has seen the same (hostname, TACK public key) pair
   multiple times, the client will "activate" a pin between the hostname
   and TACK key for a period equal to the length of time the pair has
   been observed for.  This "pin activation" process limits the impact
   of bad pins resulting from transient network attacks or operator
   error.

   TACK pins are easily communicated between clients.  For example, a
   TACK client may scan the internet to discover TACK pins, then publish
   these pins for other clients to rely upon.













Marlinspike & Perrin    Expires October 12, 2012                [Page 3]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


2.  Requirements notation

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].














































Marlinspike & Perrin    Expires October 12, 2012                [Page 4]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


3.  Overview

3.1.  TACK life cycle

   A server operator using TACK may perform several processes:

   Selection of a TACK key:  The server operator first chooses the ECDSA
      signing key to use for a set of hostnames.

   Creating initial TACKs under a TACK key:  The TACK private key is
      then used to sign the TLS public keys for all servers associated
      with those hostnames.  The TACK public key and signature are
      combined with some metadata into each server's "TACK".

   Deploying initial TACKs:  For each hostname, TACKs are deployed to
      TLS servers in a two-stage process.  First, each TLS server
      associated with the hostname is given a TACK.  Once this is
      completed, pin activation is enabled on the servers.

   Creating new TACKs under a TACK key:  A TACK must be replaced
      whenever a server changes its TLS public key, or when the TACK
      expires.  TACKs may also need to be replaced with later-generation
      TACKs if the TACK key's "min_generation" is updated (see next).

   Revoking old TACKs:  If a TLS private key is compromised, the
      affected TACKs can be revoked by publishing a new TACK containing
      a higher "min_generation".

   Revoking TACK keys:  If a TACK private key is compromised, or a
      server operator wishes to stop using TACK for any reason, a server
      can revoke an entire TACK key (including all TACKs and pins
      referring to it) by publishing a "break signature".



















Marlinspike & Perrin    Expires October 12, 2012                [Page 5]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


3.2.  Pin life cycle

   A TACK client maintains a store of pins for verifying TLS
   connections.  Pins associate a hostname and a TACK key.  When a
   client sees a new hostname and TACK key combination, an inactive pin
   is created.  Once the client has seen the pin more than once, the pin
   is "activated" for a period equal to the timespan between the first
   time the pin was seen and the most recent time, up to a maximum
   period of 30 days.

   Pin activation serves multiple purposes.  First, it prevents an
   attacker with short-lived control of the hostname from setting long-
   lived pins.  Second, it makes it safer for sites to experiment with
   TACKs, as a new TACK can be discarded without causing long-lived
   problems.  The 30 day limit on activation period guarantees that a
   worst-case pin can be recovered from in reasonable time.

   In addition to creating and activating pins, a TLS connection can
   alter the clients's pin store in two other ways:

   Min_generation:  Each pin stores the highest "min_generation" value
      it has seen from the pinned TACK key, and rejects TACKs from
      earlier generations.

   Break signatures:  A TLS handshake may send break signatures which
      cause all pins for the broken key to be discarded.

























Marlinspike & Perrin    Expires October 12, 2012                [Page 6]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


4.  TACK Extension

4.1.  Definition of TACK_Extension

   A new TLS ExtensionType ("tack") is defined and MAY be included by a
   TLS client in the ClientHello message defined in [RFC5246].

   enum {tack(TBD), (65535)} ExtensionType;

   The "extension_data" field of this ClientHello SHALL be empty.  A TLS
   server which is not resuming a TLS session MAY respond with an
   extension of type "tack" in the ServerHello.  The "extension_data"
   field of this ServerHello SHALL contain a "TACK_Extension", as
   defined below using the TLS presentation language from [RFC5246].

   enum {v1(1)} TACK_Version;
   enum (disabled(0), enabled(1)} TACK_Activation;

   struct {
      TACK_Version version;
      opaque public_key[64];
   } TACK_Key;  /* 65 bytes */

   struct {
      TACK_Key key;
      uint8  min_generation;
      uint8  generation;
      uint32 expiration;
      opaque target_sha256[32];
      opaque signature[64];
   } TACK;  /* 167 bytes */

   struct {
      TACK_Key key;
      opaque signature[64];
   } TACK_Break_Sig;  /* 129 bytes */

   struct {
      TACK tacks<0...1024>  /* 0 or more TACKs */
      TACK_Break_Sig  break_sigs<0...2048>  /* 0 or more Break Sigs */
      TACK_Activation pin_activation;
   } TACK_Extension;









Marlinspike & Perrin    Expires October 12, 2012                [Page 7]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


4.2.  Explanation of TACK_Extension fields

4.2.1.  TACK_Key fields

   version:  This field provides a version number which controls the
      interpretation of TACK and TACK_Break_Sig. A client who does not
      recognize a TACK or TACK_Break_Sig's version (which is the first
      byte of each) MUST NOT attempt to process the TACK or
      TACK_Break_Sig.

   public_key:  This field specifies the server's "TACK public key".
      The field contains a pair of integers (x, y) representing a point
      on the elliptic curve P-256 defined in [FIPS186-3].  Each integer
      is encoded as a 32-byte octet string using the Integer-to-Octet-
      String algorithm from [RFC6090], and these strings are
      concatenated with the x value first.  (NOTE: This is equivalent to
      an uncompressed subjectPublicKey from [RFC5480], except that the
      initial 0x04 byte is omitted).

4.2.2.  TACK fields

   key:  This field specifies the TACK key, and supplies the public key
      used to verify the TACK's signature.

   min_generation:  This field publishes a min_generation value.

   generation:  This field assigns each TACK a generation.  Generations
      less than a published min_generation are considered revoked.

   expiration:  This field specifies a time after which the TACK is
      considered expired.  The time is encoded as the number of minutes,
      excluding leap seconds, after midnight UTC, January 1 1970.

   target_sha256:  This field is a hash of the TLS server's
      SubjectPublicKeyInfo [RFC5280] using the SHA256 algorithm from
      [FIPS180-2].  The SubjectPublicKeyInfo is typically conveyed as
      part of the server's X.509 certificate.

   signature:  This field is an ECDSA signature by the TACK's public key
      over the ASCII string "TACK_tack" followed by the entire TACK
      structure prior to the "signature" field (i.e. the preceding 103
      bytes).  The field contains a pair of integers (r, s) representing
      an ECDSA signature as defined in [FIPS186-3], using curve P-256
      and SHA256.  Each integer is encoded as a 32-byte octet string
      using the Integer-to-Octet-String algorithm from [RFC6090], and
      these strings are concatenated with the r value first.





Marlinspike & Perrin    Expires October 12, 2012                [Page 8]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


4.2.3.  TACK_Break_Sig fields

   key:  This field specifies the TACK key being broken, and supplies
      the public key used to verify the following signature.

   signature:  This field is an ECDSA signature by the TACK_Break_Sig's
      public key over the ASCII string "TACK_break" followed by the
      entire TACK_Break_Sig structure prior to the "signature" field
      (i.e. the preceding 65 bytes of TACK_Key).  The field contains a
      pair of integers (r, s) representing an ECDSA signature as defined
      in [FIPS186-3], using curve P-256 and SHA256.  It is calculated
      and encoded as per TACK_Sig.signature.

4.2.4.  TACK_Extension fields

   tacks:  This field provides the server's TACK(s).  It MAY be empty,
      or may contain however many TACKs fit into 1 KB.  If there are
      multiple TACKs, each TACK MUST have a different version number,
      and the TACKs MUST be ordered with the lowest version first.  A
      client encountering an unrecognized version SHALL behave as if it
      had reached the end of this field, i.e. it SHALL ignore any data
      in this field following the unrecognized version byte.

   break_sigs:  This field provides break signatures.  It MAY be empty,
      or MAY contain however many break signatures fit into 2 KB.  The
      break signatures MAY have different version values.  In this case,
      the break signatures SHALL be ordered with the lowest versions
      first.  A client encountering an unrecognized version SHALL behave
      as if it had reached the end of this field, i.e. it SHALL ignore
      any data in this field following the unrecognized version byte.

   pin_activation:  If this field is "enabled", this TACK_Extension MAY
      be used by clients to activate or extend the activation of TACK
      pins.  This field is typically toggled from a disabled to an
      enabled state once TACKs have been deployed to all TLS servers for
      a hostname.

   Note that both the "tacks" and "break_sigs" fields MAY be empty.













Marlinspike & Perrin    Expires October 12, 2012                [Page 9]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


5.  Client processing

5.1.  TACK pins, key records, and host records

   A client supporting TACK SHALL have a local store of pins, consisting
   of "key records" and "host records".  Each host record is associated
   with a key record.  Multiple host records may be associated with a
   single key record.  A "pin" refers to a (host record, key record)
   pair.  Different pins can share the same key record.

   A "key record" contains:

      TACK_Key (or hash): A TACK_Key or a cryptographically-secure,
      second preimage-resistant hash of a TACK_Key. A key record
      "matches" a TACK or break signature if the key record contains the
      structure's TACK_Key or its hash.  A client SHALL NOT store
      multiple key records for the same TACK_Key.

      Min_generation: A single byte used to detect revoked TACKs.

   A "host record" contains:

      Hostname: A DNS hostname.  A client SHALL NOT store multiple host
      records with the same hostname.  A pin containing the current TLS
      connection's hostname is a "relevant" pin.

      Initial timestamp: A timestamp noting when this pin was created.

      Active period end: Empty or a timestamp.  If empty or set to a
      time in the past, the pin is "inactive".  If set to a future time,
      the pin is "active" until that time.

5.2.  High-level client processing

   A TLS client compliant with this specification SHALL send the "tack"
   extension defined previously, as well as the "server_name" extension
   from [RFC6066] indicating the hostname the client is contacting.

   If not resuming a session, the server MAY respond with a
   TACK_Extension.  If so, the TLS client SHALL perform the following
   steps prior to using the TLS connection:

   1.  Discard pins based on break signatures (if present).

   2.  Check for a valid TACK.

   3.  Update and activate pins based on the valid TACK (if present).




Marlinspike & Perrin    Expires October 12, 2012               [Page 10]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


   If, after the above steps, there is a relevant active pin and a valid
   matching TACK, then the connection is verified by the pin.  If there
   is a relevant active pin but no such TACK, the connection is rejected
   by the pin.  A rejected connection may indicate a network attack or
   some other communication failure, and a client SHOULD NOT send or
   receive data on such a connection.  However, the details of how a
   client chooses to handle these different cases is out of scope of
   this specification.

5.3.  Client processing details

5.3.1.  Discarding pins based on break signatures

   All key records broken by break signatures SHALL be discarded, along
   with their associated host records.  A key record is broken by a
   break signature if the following statements are true:

   1.  The break signature's version field is recognized.

   2.  The break signature "matches" the key record.

   3.  The break signature's "signature" field is a correct ECDSA
       signature over the break signature's contents when verified using
       the break signature's public key.

5.3.2.  Checking for a valid TACK

   A v1 TACK is "valid" if the below checks are true.  (Checking the
   validity of other TACK versions is not defined in this
   specification).

   1.  The version field is recognized.

   2.  The TACK_Sig.generation is >= TACK_Sig.min_generation.

   3.  The TACK_Sig.expiration is non-expired.

   4.  The TACK_Sig.target_sha256 is equal to the SHA256 hash of the
       server's SubjectPublicKeyInfo.

   5.  The TACK_Sig.signature is a correct ECDSA signature over the
       TACK's contents when verified using the TACK's public key.

   6.  The TACK_Sig.generation is >= the min_generation of any key
       record in the client's store which matches the TACK.

   7.  The TLS handshake completes successfully.




Marlinspike & Perrin    Expires October 12, 2012               [Page 11]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


5.3.3.  Updating and activating pins based on the TACK

   A valid TACK is used to update the client's pin store.  If there is a
   key record matching the TACK, the key record's min_generation SHALL
   be set to the TACK's min_generation if the TACK's value is larger.

   A valid TACK MAY also be used to modify the host records using the
   "pin activation" process described below.  Note that the following
   steps are optional; a client MAY rely on an external source of pins.

   If there is a relevant pin matching the TACK, and the TACK
   Extension's "pin_activation" is enabled, the host record's "active
   period end" MAY be set according to the following formula (where
   "current" is the current time, and "initial" is the "initial
   timestamp" from the host record):

   active_period_end = current + MIN(30 days, current - initial)

   If there is no relevant pin, or only an inactive one which does not
   match the TACK, a new pin MAY be created with the following steps:

   1.  If the TACK's key matches an existing key record, the key record
       is reused, otherwise a new key record is created with the TACK's
       key and min_generation.

   2.  A new host record is created containing the server's hostname, an
       "initial timestamp" equal to the current time, and an empty
       "active period end".

   3.  If there was an existing relevant host record, it is discarded.

   The following table summarizes this behavior based on whether the
   relevant pin is active and matches the TACK.  The "(*)" means "if
   TACK_Extension.pin_activation is enabled".

    +------------+-------------------+-------------------------------+
    | Pin status | TACK matches pin? | Result                        |
    +------------+-------------------+-------------------------------+
    | Active     | Yes               | Extend activation period (*)  |
    |            |                   |                               |
    | Active     | No                | Rejected                      |
    |            |                   |                               |
    | Inactive   | Yes               | Activate pin (*)              |
    |            |                   |                               |
    | Inactive   | No                | Replace with new inactive pin |
    |            |                   |                               |
    | None       | -                 | Create new inactive pin       |
    +------------+-------------------+-------------------------------+



Marlinspike & Perrin    Expires October 12, 2012               [Page 12]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


6.  TACK IDs

   A "TACK ID" MAY be used to represent a TACK_Key to users in a form
   that is (somewhat) easy to visually compare and transcribe.  A TACK
   ID is a string of alphanumeric characters and periods encoding 125
   bits of data.  The first 5 bits of data contain the TACK_Key's
   version (note that TACK IDs are not compatible with versions greater
   than 31).  For a v1 TACK_Key, the following 120 bits contain the
   first 120 bits of SHA256(TACK_Key).

   Each of the 25 5-bit values in the TACK ID is encoded into a
   character by representing the value as a number from 0-31, then
   choosing the appropriate character from the below alphabet (where 0
   is 'a', 1 is 'b', ..., 31 is '9').  The 25 encoded characters are
   then split into five groups of five characters, separated by periods.

   The TACK ID alphabet is "abcdefghijkLmn1pqrstuvwxy3456789".  The
   alphabet is constructed of lowercase letters and numbers, with the
   visually similar pairs ('0', 'o') and ('2', 'z') omitted, and the
   visually similar pair ('1', 'l') disambiguated by capitalizing the
   letter 'L'.  The alphabet is ordered so as to allow easy encoding
   using an [RFC4648] base32 encoder (see Appendix A).

   Example TACK IDs:

      buw81.a3sm4.8wpL6.t3vaq.gghaL

      bd867.imy99.k8egk.Lynjx.68c6s

      baemb.9bw7r.y75tn.7d88r.fh9ua





















Marlinspike & Perrin    Expires October 12, 2012               [Page 13]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


7.  Advice

7.1.  For server operators

   Key reuse:  All servers that are pinned to a single key are able to
      impersonate each other.  Thus, different keys should be used to
      pin hostnames with different security properties.

   Generations:  To revoke older generations of TACKs, the server
      operator should first provide all servers with a new generation of
      TACKs, then provide servers with new TACKs containing the new
      min_generation.  This is safer then trying to update
      min_generation and generation simultaneously across a range of
      servers, since a client may receive a min_generation update from
      one server but then try to contact a server which has not yet been
      updated, and still has an older-generation TACK.

   Signature expiration:  It is convenient to set the TACK signature
      expiration equal to the end-entity certificate expiration, so that
      the TACK and certificate may both be replaced at the same time.
      Alternatively, short-lived TACK signatures may be used so that a
      compromised TLS private key has limited value to an attacker.

   Break signatures:  Break signatures are useful if a server wishes to
      abruptly change its TACK key, stop using TACKs, or advertise that
      a TACK key is compromised and clients should stop relying on it.
      A break signature only needs to be published for a time interval
      equal to the maximum active period of any affected pins.  For
      example, if a TACK has been only been published on a website for
      24 hours, removing the TACK requires only publishing the break
      signature for 24 hours.

   Pin activation:  The pin_activation field should only be toggled to
      "enabled" once all TLS servers sharing the same hostname have a
      valid TACK.  Otherwise, a client may activate a pin by contacting
      one server, then contact a different server at the same hostname
      that does not yet have a valid TACK.  The pin_activation field can
      also be used to phase out use of TACKs for a hostname - if all
      servers at a hostname disable pin activation, existing pins will
      eventually all become deactivated (within 30 days at most).











Marlinspike & Perrin    Expires October 12, 2012               [Page 14]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


7.2.  For client implementors

   Sharing pin information:  It is possible for a client to maintain a
      pin store based entirely on its own TLS connections.  However,
      such a client runs the risk of creating incorrect pins, failing to
      keep its pins active, or failing to receive revocation information
      (min_generation updates and break signatures).  Clients are
      advised to collaborate so that pin data can be aggregated and
      shared.  This will likely require additional protocols and
      infrastructure outside the scope of this document.









































Marlinspike & Perrin    Expires October 12, 2012               [Page 15]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


8.  Security considerations

   All servers sharing a TACK key can impersonate each other.  Use
   different TACK keys for servers with different security properties.

   Make backup copies of the TACK private key and keep all copies in
   secure locations where they can't be compromised.

   A TACK private key MUST NOT be used to perform any non-TACK
   cryptographic operations.  For example, using a TACK elliptic curve
   key for email encryption, code-signing, or any other purpose MUST NOT
   be done.

   HTTP cookies [RFC6265] set by a pinned host can be stolen by a
   network attacker who can forge web and DNS responses so as to cause a
   client to send the cookies to a phony subdomain of the pinned host.
   To prevent this, TACK HTTPS Servers SHOULD set the "secure" attribute
   and omit the "domain" attribute on all security-sensitive cookies,
   such as session cookies.  These attribute settings tell the browser
   that the cookie should only be presented back to the originating host
   (not its subdomains), and should only be sent over HTTPS (not HTTP)
   [RFC6265].





























Marlinspike & Perrin    Expires October 12, 2012               [Page 16]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


9.  IANA considerations

9.1.  New entry for the TLS ExtensionType Registry

   IANA is requested to add an entry to the existing TLS ExtensionType
   registry, defined in RFC 5246, for tack(TBD) as defined in this
   document.

9.2.  New registry for TACK_Version

   IANA is requested to establish a new registry for TLS TACK_Version.
   The initial entries in TACK_Version are 0(reserved), and 1(v1).  The
   policy for adding new values to this registry, following the
   terminology defined in [RFC5226], is Expert Review.

   The designated expert is expected to consult the TLS mailing list or
   its designated successor, as well as review any documentation to
   determine whether the extension will be widely useful and is fully
   documented.  To preserve the limited number of code points and
   maximize interoperability, the presumption should be that a code
   point SHOULD NOT be granted, unless there is a compelling reason to
   the contrary.





























Marlinspike & Perrin    Expires October 12, 2012               [Page 17]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


10.  Acknowledgements

   Valuable feedback has been provided by Adam Langley, Chris Palmer,
   Nate Lawson, and Joseph Bonneau.















































Marlinspike & Perrin    Expires October 12, 2012               [Page 18]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


11.  Normative references

   [FIPS180-2]
              National Institute of Standards and Technology, "Secure
              Hash Standard", FIPS PUB 180-2, August 2002, <http://
              csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf>.

   [FIPS186-3]
              National Institute of Standards and Technology, "Digital
              Signature Standard", FIPS PUB 186-3, June 2009, <http://
              csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, October 2006.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              May 2008.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008.

   [RFC5480]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Elliptic Curve Cryptography Subject Public Key
              Information", RFC 5480, March 2009.

   [RFC6066]  Eastlake, D., "Transport Layer Security (TLS) Extensions:
              Extension Definitions", RFC 6066, January 2011.

   [RFC6090]  McGrew, D., Igoe, K., and M. Salter, "Fundamental Elliptic
              Curve Cryptography Algorithms", RFC 6090, February 2011.

   [RFC6265]  Barth, A., "HTTP State Management Mechanism", RFC 6265,
              April 2011.









Marlinspike & Perrin    Expires October 12, 2012               [Page 19]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


Appendix A.  Implementing the TACK ID alphabet

   The most complex step in creating a TACK ID is encoding the first 120
   bits from SHA256(TACK_Key) into 24 characters from the TACK ID
   alphabet.  An [RFC4648] base32 encoder can be used to simplify the
   process, as follows:

   1.  Apply the base32 encoding from [RFC4648] to convert the 120 bits
       to 24 lowercase base32 characters.

   2.  Convert the base32 characters to TACK ID characters by adding 2
       to all base32 numerals (changing '2' to '4', '3' to '5', etc.)
       and converting 'l' to 'L', 'o' to '1', and 'z' to '3'.






































Marlinspike & Perrin    Expires October 12, 2012               [Page 20]

Internet-Draft    Trust Assertions for Certificate Keys       April 2012


Authors' Addresses

   Moxie Marlinspike


   Trevor Perrin (editor)













































Marlinspike & Perrin    Expires October 12, 2012               [Page 21]

