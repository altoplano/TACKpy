


No working group                                          M. Marlinspike
Internet-Draft                                            T. Perrin, Ed.
Expires: September 15, 2012                               March 14, 2012


                 Trust Assertions for Certificate Keys
                           draf-ietf-tack-00

Abstract

   This document defines TACK, a TLS Extension that enables a TLS server
   to assert the authenticity of its public key.  A TACK contains a
   "TACK signing key" and a "TACK signature" from that key over the TLS
   server's public key.  Hostnames can be "pinned" to a TACK key.  TLS
   connections to a pinnned hostname are only considered verified if the
   server presents a TACK containing the pinned TACK key and a valid
   TACK signature.

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on September 15, 2012.

Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as



Marlinspike & Perrin   Expires September 15, 2012               [Page 1]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


   described in the Simplified BSD License.


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Requirements notation  . . . . . . . . . . . . . . . . . . . .  4
   3.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
     3.1.  TACK life cycle  . . . . . . . . . . . . . . . . . . . . .  5
     3.2.  Pin life cycle . . . . . . . . . . . . . . . . . . . . . .  6
   4.  TACK Extension . . . . . . . . . . . . . . . . . . . . . . . .  7
     4.1.  Definition of TACK_Extension . . . . . . . . . . . . . . .  7
     4.2.  Explanation of TACK_Extension fields . . . . . . . . . . .  8
       4.2.1.  TACK_Key fields  . . . . . . . . . . . . . . . . . . .  8
       4.2.2.  TACK_Sig fields  . . . . . . . . . . . . . . . . . . .  8
       4.2.3.  TACK fields  . . . . . . . . . . . . . . . . . . . . .  9
       4.2.4.  TACK_Break_Sig fields  . . . . . . . . . . . . . . . .  9
       4.2.5.  TACK_Extension fields  . . . . . . . . . . . . . . . .  9
   5.  Client processing  . . . . . . . . . . . . . . . . . . . . . . 10
     5.1.  TACK pins, key records, and host records . . . . . . . . . 10
     5.2.  High-level client processing . . . . . . . . . . . . . . . 10
     5.3.  Client processing details  . . . . . . . . . . . . . . . . 11
       5.3.1.  Discarding pins based on break signatures  . . . . . . 11
       5.3.2.  Checking whether the TACK is valid . . . . . . . . . . 11
       5.3.3.  Updating and activating pins based on the TACK . . . . 12
   6.  Miscellaneous  . . . . . . . . . . . . . . . . . . . . . . . . 13
     6.1.  TACK IDs . . . . . . . . . . . . . . . . . . . . . . . . . 13
     6.2.  Cookies and TACKs  . . . . . . . . . . . . . . . . . . . . 13
   7.  Advice . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
     7.1.  For server operators . . . . . . . . . . . . . . . . . . . 14
     7.2.  For client implementors  . . . . . . . . . . . . . . . . . 15
   8.  Security Considerations  . . . . . . . . . . . . . . . . . . . 16
   9.  Normative References . . . . . . . . . . . . . . . . . . . . . 17
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 18

















Marlinspike & Perrin   Expires September 15, 2012               [Page 2]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


1.  Introduction

   Traditionally, a TLS client verifies a TLS server's public key by
   checking the server's X.509 certificate chain.  It is becoming
   increasingly important for TLS clients to have other means for
   verifing server public keys.

   One alternative is for clients to employ some sort of "pinning",
   where the client uses past connections to verify future connections
   by checking for some constant element.  Unfortunately, a number of
   problems arise when attempting to pin X.509 certificate chains: the
   TLS servers at a given hostname may have different certificate
   chains, and may change their chains at any time; the "more constant"
   elements of a chain - the CAs - may not be trustworthy; and the
   client employing pinning may be oblivious to key compromise events
   which render the pinned data untrustworthy.

   TACK addresses these problems by having the site choose a TACK
   signing key which it uses to sign TLS server public keys.  This
   enables clients to "pin" a hostname to the TACK key without
   preventing the TLS servers from using different certificate chains or
   changing certificate chains, and without needing trust in CAs.
   Additionally, the TACK key may be used to revoke previous TACK
   signatures or even itself, to handle compromise of TLS or TACK
   private keys.

   If requested by a client, the server will send a TLS Extension
   containing its "TACK".  Inside the TACK is a TACK public key and TACK
   signature.  Once a client has seen the same (hostname, TACK public
   key) combination multiple times, the client will "activate" a pin
   between the hostname and TACK key for a period equal to the length of
   time the combination has been observed for.  This "pin activation"
   process limits the impact of bad TACKs resulting from transient
   network attacks or operator error.

   TACK pins are easily communicated between clients.  For example, a
   TACK client may scan the internet to discover TACK pins, then publish
   these pins for other clients to rely upon.













Marlinspike & Perrin   Expires September 15, 2012               [Page 3]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


2.  Requirements notation

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].














































Marlinspike & Perrin   Expires September 15, 2012               [Page 4]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


3.  Overview

3.1.  TACK life cycle

   A server operator using TACK may perform several processes:

   Selection of a TACK key:  The server operator first chooses the ECDSA
      signing key to use for a set of hostnames.

   Creating initial TACKs under a TACK key:  The TACK private key is
      then used to sign the TLS public keys for all servers associated
      with those hostnames.  The TACK public key and signature are
      combined with some metadata into each server's "TACK".

   Creating new TACKs under a TACK key:  A TACK must be replaced
      whenever a server changes its TLS public key, or when a TACK
      signature expires.  TACKs may also need to be replaced with later-
      generation TACKs if the TACK key's "min_generation" is updated
      (see next).

   Revoking old TACKs:  If a TLS private key is compromised, the
      affected TACKs can be revoked by publishing a new TACK containing
      a higher "min_generation".

   Revoking TACK keys:  If a TACK private key is compromised, or a
      server operator wishes to stop using TACK for any reason, a server
      can revoke an entire TACK key (including all TACKs and pins
      referring to it) by publishing a "break signature".























Marlinspike & Perrin   Expires September 15, 2012               [Page 5]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


3.2.  Pin life cycle

   A TACK client maintains a store of pins for verifying TLS
   connections.  Pins associate a hostname and a TACK key.  When a
   client sees a new hostname and TACK key combination, an inactive pin
   is created.  Once the client has seen the pin more than once, the pin
   is "activated" for a period equal to the timespan between the first
   time the pin was seen and the most recent time, or a maximum period
   of 30 days.

   This "pin activation" process serves multiple purposes.  First, it
   prevents an attacker with short-lived control of the hostname from
   setting long-lived pins.  Second, it makes it safer for sites to
   experiment with TACKs, as a new TACK can be discarded without causing
   long-lived problems.  The 30 day limit on activation period
   guarantees that a worst-case pin can be recovered from in reasonable
   time.

   In addition to creating and activating pins, a TLS connection can
   alter the clients's pin store in two other ways:

   Min_generation:  Each pin stores the highest "min_generation" value
      it has seen from the pinned TACK key.

   Break signatures:  A TLS handshake may send break signatures which
      cause all pins for the broken key to be discarded.

























Marlinspike & Perrin   Expires September 15, 2012               [Page 6]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


4.  TACK Extension

4.1.  Definition of TACK_Extension

   A new TLS ExtensionType ("tack") is defined and MAY be included by a
   TLS client in the (extended) client hello.

   enum {tack(TBD), (65535)} ExtensionType;

   The "extension_data" field of this extension SHALL be empty.  A TLS
   server which is not resuming a TLS session MAY respond with an
   extension of type "tack" in the server hello.  The "extension_data"
   field of this extension SHALL contain a "TACK_Extension", as defined
   below using the TLS presentation language.

   enum {v1(1)} TACK_Key_Type;
   enum {v1(1)} TACK_Sig_Type;

   struct {
      TACK_Key_Type type;
      opaque public_key[64];
   } TACK_Key;  # 65 bytes

   struct {
      TACK_Sig_Type type;
      uint8  min_generation;
      uint8  generation;
      uint32 expiration;
      opaque target_sha256[32];
      opaque signature[64];
   } TACK_Sig;  # 103 bytes

   struct {
      TACK_Key key;
      TACK_Sig sig;
   } TACK;  # 168 bytes

   struct {
      TACK_Key key;
      opaque signature[64];
   } TACK_Break_Sig;  # 129 bytes

   struct {
      TACK tack<0...1024>   # 0 or 1 TACKs
      TACK_Break_Sig break_sigs<0...2048>   # 0 or more Break Signatures
   } TACK_Extension;





Marlinspike & Perrin   Expires September 15, 2012               [Page 7]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


4.2.  Explanation of TACK_Extension fields

4.2.1.  TACK_Key fields

   type:  This field provides a version number which controls the
      interpretation of TACK and TACK_Break_Sig. A client who does not
      recognize a TACK or TACK_Break_Sig's TACK_Key.type MUST NOT
      attempt further interpretation of the TACK or TACK_Break_Sig.

   public_key:  This field specifies the server's "TACK key" as an
      elliptic curve public key on the NIST P-256 curve.  The field
      contains a pair of nonnegative integers (x,y) representing a point
      on the elliptic curve P-256 defined in FIPS 186-3.  Each integer
      is less than 2^256.  Each integer is encoded as a 32-byte octet
      string using the Integer-to-Octet-String algorithm from SEC1, and
      these strings are concatenated with the x value first to produce a
      64-byte octet string.  (NOTE: This is equivalent to an
      uncompressed subjectPublicKey from SEC1, except that the initial
      0x04 byte from subjectPublicKey is omitted).

4.2.2.  TACK_Sig fields

   type:  This field provides a version number which controls the
      interpretation of the TACK_Sig structure.  A client who does not
      recognize a TACK_Sig.type MUST NOT attempt further interpretation
      of the TACK_Sig. This document specifies a single value for this
      field: "v1" which specifies that the "target_sha256" field
      contains a hash of the TLS server's SubjectPublicKeyInfo (as
      conveyed through the end-entity X.509 certificate or some other
      means, including any future TLS handshake protocols which convey
      the server's SubjectPublicKeyInfo without using a certificate).

   min_generation:  This field publishes a min_generation value.

   generation:  This field assigns each TACK a generation.  Generations
      less than a published min_generation are considered revoked.

   expiration:  This field specifies a check that is applied to the
      current UTC time to determine whether the TACK signature is
      expired.  If the current UTC time, when converted to an integer
      via the algorithm in POSIX.1, is greater than or equal to the
      value expiration*60, the signature is expired.

   target_sha256:  This field is a SHA256 hash of a
      SubjectPublicKeyInfo.






Marlinspike & Perrin   Expires September 15, 2012               [Page 8]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


   signature:  This field is an ECDSA-P256-SHA256 signature over the
      entire TACK structure prior to the "signature" field (i.e. the
      preceding 104 bytes).  The field contains a pair of nonnegative
      integers (r,s) representing an ECDSA signature as defined in FIPS
      186-3.  Each integer is less than 2^256.  Each integer is encoded
      as a 32-byte octet string using the Integer-to-Octet-String
      algorithm from SEC1, and these strings are concatenated with the r
      value first to produce a 64-byte octet string.

4.2.3.  TACK fields

   key:  This field specifies the TACK's key.

   sig:  This field specifies the TACK's signature and related fields.

4.2.4.  TACK_Break_Sig fields

   key:  This field specifies the TACK key being broken, and supplies
      the public key used to verify the following signature.

   signature:  This field is an ECDSA-P256-SHA256 signature over the
      entire TACK_Break_Sig structure prior to the "signature" field
      (i.e. the preceding 65 bytes).  It is encoded as per
      TACK_Sig.signature.

4.2.5.  TACK_Extension fields

   tack:  This field provides the server's TACK, if any.

   break_sigs:  This field provides break signatures.  It MAY be empty,
      or MAY contain however many break signatures fit into 2 KB.  The
      break signatures MAY have different TACK_Key.type values.  In this
      case, they SHALL be ordered with the lowest types first, so that a
      client that does not recognize the later types can stop processing
      the break signatures list once it encounters an unrecognized
      TACK_Key.type.

   Note that both the "tack" and "break_sigs" fields MAY be empty.













Marlinspike & Perrin   Expires September 15, 2012               [Page 9]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


5.  Client processing

5.1.  TACK pins, key records, and host records

   A client supporting TACK SHALL have a local store of pins, consisting
   of "key records" and "host records".  Each host record is pinned to a
   key record.  Multiple host records may be pinned to a single key
   record.  A "pin" refers to a (host record, key record) pair.
   Different pins can share the same key record.

   A "key record" contains:

      TACK_Key (or hash): A TACK_Key or a cryptographically-secure,
      second preimage-resistant hash of a TACK_Key. A key record
      "matches" a TACK or break signature if the key record contains the
      structure's TACK_Key or its hash.  A client SHALL NOT store
      multiple key records for the same TACK_Key.

      Min_generation: A single byte used to detect revoked TACKs.

   A "host record" contains:

      Hostname: A DNS hostname.  A pin containing the current TLS
      connection's hostname is a "relevant" pin.  A client SHALL NOT
      store multiple host records with the same hostname.

      Initial timestamp: A timestamp noting when this pin was created.

      Active period end: Empty or a timestamp.  If empty or set to a
      time in the past, the pin is "inactive".  If set to a future time,
      the pin is "active" until that time.

5.2.  High-level client processing

   A TLS client compliant with this specification SHALL send the "tack"
   extension defined previously, as well as a "server_name" extension
   indicating the hostname the client is contacting.

   If not resuming a session, the server MAY respond with a
   TACK_Extension.  If so, the TLS client SHALL perform the following
   steps prior to using the TLS connection:

   1.  Discard pins based on break signatures (if present).

   2.  Check whether the TACK is valid (if present).

   3.  Update and activate pins based on the TACK (if valid).




Marlinspike & Perrin   Expires September 15, 2012              [Page 10]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


   If a TLS session that had a valid TACK is being resumed, step 1 above
   is skipped and the session's TACK is used for steps 2 and 3.

   If, after the above steps, there is a relevant active pin and a valid
   matching TACK, then the connection is verified by the pin.  If there
   is a relevant active pin but no such TACK, the connection is rejected
   by the pin.  If there is no relevant active pin, the connection is
   unverified by a pin.  How these different cases affect client
   behavior is out of scope of this specification.

5.3.  Client processing details

5.3.1.  Discarding pins based on break signatures

   All key records broken by break signatures SHALL be discarded, along
   with their associated host records.  A key record is broken by a
   break signature if the following statements are true:

   1.  The break signature's TACK_Key.type field is recognized.

   2.  The break signature "matches" the key record.

   3.  The break signature's "signature" field is a correct ECDSA
       signature over the break signature's contents when verified using
       the break signature's "public_key".

5.3.2.  Checking whether the TACK is valid

   A TACK is "valid" if the following checks are true:

   1.  The TACK_Key.type and TACK_Sig.type fields are recognized.

   2.  The TACK_Sig.generation is >= TACK_Sig.min_generation.

   3.  The TACK_Sig.expiration is non-expired.

   4.  The TACK_Sig.target_sha256 is equal to the SHA256 hash of the
       server's SubjectPublicKeyInfo (or a session is being resumed).

   5.  The TACK_Sig.signature is a correct ECDSA signature over the
       TACK's contents when verified using the TACK's "public_key".

   6.  The TACK_Sig.generation is >= the min_generation of any key
       record in the client's store which matches the TACK.

   7.  The TLS handshake completes successfully.





Marlinspike & Perrin   Expires September 15, 2012              [Page 11]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


5.3.3.  Updating and activating pins based on the TACK

   A valid TACK is used to update the client's pin store.  If there is a
   key record matching the TACK, the key record's min_generation SHALL
   be set to the TACK's min_generation if the TACK's value is larger.

   A valid TACK MAY also be used to modify the host records using the
   "pin activation" process described below.  Note that the following
   steps are optional; a client MAY rely on an external source of pins,
   and not perform pin activation.

   If there is a relevant pin matching the TACK, the host record's
   "active period end" MAY be set according to the following formula
   (where "current" is the current time, and "initial" is the "initial
   timestamp" from the host record:


   active_period_end = current + MIN(30 days, current - initial)


   If there is no relevant pin, or only an inactive one which does not
   match the TACK, a new host record MAY be created.  If the TACK's key
   matches an existing key record, the key record is reused, otherwise a
   new key record is created with the TACK's key and min_generation.
   The new host record is created containing the server's hostname, an
   "initial" timestamp equal to the current time, and an empty "active
   period end".  If there was an existing relevant host record, it is
   discarded.

   The following table summarizes this behavior depending on whether the
   relevant pin is active or inactive (or none), and whether the TACK
   matches the pin.

    +------------+-------------------+-------------------------------+
    | Pin status | TACK matches pin? | Result                        |
    +------------+-------------------+-------------------------------+
    | Active     | Yes               | Extend activation period      |
    |            |                   |                               |
    | Active     | No                | Rejected                      |
    |            |                   |                               |
    | Inactive   | Yes               | Activate pin                  |
    |            |                   |                               |
    | Inactive   | No                | Replace with new inactive pin |
    |            |                   |                               |
    | None       | -                 | Create new inactive pin       |
    +------------+-------------------+-------------------------------+





Marlinspike & Perrin   Expires September 15, 2012              [Page 12]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


6.  Miscellaneous

6.1.  TACK IDs

   To display TACK information to users in a consistent form, a "TACK
   ID" MAY be used to represent a TACK_Key. A TACK ID is a base32
   encoding of 5 bits TACK ID version (=0x01) followed by the first 120
   bits of SHA256(TACK_Key), using the base32 alphabet
   "ABCDEFGHIJKLMNPQRSTUVWXY13456789".  Examples:

      BJFVI.U5YFA.WXMIW.CQGFW.APVIF

      B3LBX.KWYAP.A8CT1.4IFE8.JDQPT

      BUT93.HCELT.SU745.LA44H.WJFGF

6.2.  Cookies and TACKs

   HTTP cookies with a "secure" atttribute (aka "secure cookies") set
   over a TLS connection with a valid TACK SHALL be bound to the TACK's
   TACK_Key. Clients SHALL only send these cookies over TLS connections
   with a valid TACK containing the same TACK_Key.

   Note that the decisions to bind a cookie received over a TLS
   connection to a TACK_Key, and to send such a cookie over a TLS
   connection, do not take into account whether the TLS connections are
   verified by a pin, rejected by a pin, or unverified by a pin.
























Marlinspike & Perrin   Expires September 15, 2012              [Page 13]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


7.  Advice

7.1.  For server operators

   Key reuse:  All servers that are pinned to a single key are able to
      impersonate each other.  Thus, different keys should be used to
      pin hostnames with different security properties.  However, all
      servers sharing secure cookies must be pinned to the same key.
      Due to cookie scoping rules, it will often be desirable to pin web
      servers under a single DNS domain to a single key.

   Generation:  To revoke older generations of TACKs, the server
      operator should first provide all servers with a new generation of
      TACKs, then provide servers with new TACKs containing the new
      min_generation.  This is safer then trying to update
      min_generation and generation simultaneously across a range of
      servers, since a client may receive a min_generation update from
      one server but then try to contact a server which has not yet been
      updated, and still has an older-generation TACK.

   Signature expiration:  It is convenient to set the TACK signature
      expiration equal to the end-entity certificate expiration, so that
      the TACK and certificate may both be replaced at the same time.
      Alternatively, short-lived TACK signatures may be used so that a
      compromised TLS private key has limited value to an attacker.

   Break signatures:  Break signatures are useful if a server wishes to
      abruptly change its TACK key, stop using TACKs, or advertise that
      a TACK key is compromised and clients should stop relying on it.
      A break signature only needs to be published for a time interval
      equal to the maximum active period of any affected pins.  For
      example, if a TACK key has only been used for a TACK which has
      been published on a website for 24 hours, the break signature only
      needs to be published for 24 hours.

















Marlinspike & Perrin   Expires September 15, 2012              [Page 14]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


7.2.  For client implementors

   Sharing pin information:  It is possible for a client to maintain a
      pin store based entirely on its own TLS connections.  However,
      such a client runs the risk of creating incorrect pins, failing to
      keep its pins active, or failing to receive min_generation updates
      and break signatures.  Clients are advised to collaborate so that
      pin data can be aggregated and shared.  This will likely require
      additional protocols and infrastructure outside the scope of this
      document.









































Marlinspike & Perrin   Expires September 15, 2012              [Page 15]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


8.  Security Considerations

   All servers sharing a TACK key can impersonate each other.  Use
   different TACK keys for servers with different security properties.

   Make backup copies of the TACK private key and keep all copies in
   secure locations where they can't be compromised.












































Marlinspike & Perrin   Expires September 15, 2012              [Page 16]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


9.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.















































Marlinspike & Perrin   Expires September 15, 2012              [Page 17]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


Authors' Addresses

   Moxie Marlinspike


   Trevor Perrin (editor)













































Marlinspike & Perrin   Expires September 15, 2012              [Page 18]

