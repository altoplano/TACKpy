<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" []>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>

<rfc ipr="trust200902" docName="draft-tack.txt" category="std">

    <front>
        <title>Trust Assertions for Certificate Keys</title>
        <author initials='M.M.' surname="Marlinspike" fullname='Moxie Marlinspike'>	
            <organization/>
        </author>
        <author initials='T.P.' surname="Perrin" fullname='Trevor Perrin' 
				role="editor">
            <organization/>
        </author>
        <date/>
		<area>Security</area>
		<workgroup>TLS Working Group</workgroup>
        <abstract>
			<t>

This document defines TACK, a TLS Extension that enables a TLS server to
assert the authenticity of its public key. A TACK contains a "TACK signing
key" and a corresponding "TACK signature" over the public key from the TLS
server's certificate. Hostnames can be "pinned" to a TACK key. TLS connections
to a pinnned hostname are only considered verified if the server presents a
valid signature from the pinned key.

			</t>
		</abstract>
    </front>

    <middle>
		<section anchor="intro" title="Introduction">
			<t>

Traditionally, a TLS client verifies a TLS server's public key using a
certificate chain issued by some public CA. TACK facilitates stronger methods
of verifying server public keys.

 </t> <t>

One such method is for clients to employ "pinning", in which the client uses
past connections to verify future connections by checking for some constant
element. Unfortunately, a number of problems arise when attempting to pin
certificate chains: the TLS servers at a given hostname may have different
certificate chains and may change their chains at any time; the "more
constant" elements of a chain - the CAs - may not be trustworthy; and the
client employing pinning may be oblivious to key compromise events which
render the pinned data untrustworthy.

			</t> 

	<t>

TACK addresses these problems by having the site choose a TACK signing key,
which is used to sign TLS server public keys. This enables clients to "pin" a
hostname to the TACK key without requiring sites to modify their existing
certificate chains, and without limiting a site's flexibility to deploy
different certificate chains on different servers or change certificate
chains at any time. Since TACK pins are based on TACK keys (instead of CA
keys), trust in CAs is not required. Additionally, the TACK key may be used to
revoke previous TACK signatures or even itself, to handle compromise of TLS or
TACK private keys.

	</t>
	<t>

If requested by a client, a compliant server will send a TLS Extension
containing its "TACK". Inside the TACK is a TACK public key and TACK
signature. Once a client has seen the same (hostname, TACK public key) pair
multiple times, the client will "activate" a pin between the hostname and TACK
key for a period equal to the length of time the pair has been observed for.
This "pin activation" process limits the impact of bad pins resulting from
transient network attacks or operator error.

			</t>
			<t>

TACK pins are easily communicated between clients. For example, a TACK client
may scan the internet to discover TACK pins, then publish these pins for other
clients to rely upon.

</t>

 </section> 


<section title="Requirements notation"> <t>The key words "MUST",
"MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in <xref target="RFC2119"/>.</t> 
</section>

<section title="Overview">

<section title="TACK life cycle">

<t>A server operator using TACK may perform several processes:

	<list style="hanging">
	<t hangText="Selection of a TACK key:">	

The server operator first chooses the ECDSA signing key to use for a set of
hostnames.

	</t>
	<t hangText="Creating initial TACKs under a TACK key:">	

The TACK private key is then used to sign the TLS public keys for all servers
associated with those hostnames. The TACK public key and signature are
combined with some metadata into each server's "TACK".

	</t>
	<t hangText="Deploying initial TACKs:">	

For each hostname, TACKs are deployed to TLS servers in a two-stage process.
First, each TLS server associated with the hostname is given a TACK. Then, pin
activation is enabled on each server, so that clients may begin activating
pins.

	</t>
	
	<t hangText="Creating new TACKs under a TACK key:">	

A TACK must be replaced whenever a server changes its TLS public key, or when
a TACK signature expires. TACKs may also need to be replaced with
later-generation TACKs if the TACK key's "min_generation" is updated (see
next).

	</t>
	<t hangText="Revoking old TACKs:">

If a TLS private key is compromised, the affected TACKs can be revoked by
publishing a new TACK containing a higher "min_generation".

	</t>
	<t hangText="Revoking TACK keys:">

If a TACK private key is compromised, or a server operator wishes to stop
using TACK for any reason, a server can revoke an entire TACK key (including
all TACKs and pins referring to it) by publishing a "break signature".

	</t>
	</list>
	<vspace blankLines="100" />	
</t>
	

</section>

<section title="Pin life cycle">
	
	<t>

A TACK client maintains a store of pins for verifying TLS connections. Pins
associate a hostname and a TACK key. When a client sees a new hostname and
TACK key combination, an inactive pin is created. Once the client has seen the
pin more than once, the pin is "activated" for a period equal to the timespan
between the first time the pin was seen and the most recent time, up to a
maximum period of 30 days.

</t> <t>

Pin activation serves multiple purposes. First, it prevents an attacker with
short-lived control of the hostname from setting long-lived pins. Second, it
makes it safer for sites to experiment with TACKs, as a new TACK can be
discarded without causing long-lived problems. The 30 day limit on activation
period guarantees that a worst-case pin can be recovered from in reasonable
time.

</t>


 <t>In addition to creating and activating pins, a TLS connection can alter the
   clients's pin store in two other ways:<list
style="hanging"> <t hangText="Min_generation:">

Each pin stores the highest "min_generation" value it has seen from the pinned
TACK key, and rejects TACKs from earlier generations.

	</t>

	<t hangText="Break signatures:">

A TLS handshake may send break signatures which cause all pins for the
broken key to be discarded.

	</t>

	</list>
	</t>
</section>
</section>

<section title="TACK Extension">
	<section title="Definition of TACK_Extension">
	<t>

A new TLS ExtensionType ("tack") is defined and MAY be included by a TLS
client in the ClientHello message defined in <xref target="RFC5246"/>.

</t>
<figure><artwork>
enum {tack(TBD), (65535)} ExtensionType;
</artwork></figure>	
<t>

The "extension_data" field of this ClientHello SHALL be empty. A TLS server
which is not resuming a TLS session MAY respond with an extension of type
"tack" in the ServerHello. The "extension_data" field of this ServerHello
SHALL contain a "TACK_Extension", as defined below using the TLS presentation
language from <xref target="RFC5246"/>.

	</t>
<figure><artwork>
enum {v1(1)} TACK_Version;
enum {v1_spki(1), v1_break(2)} TACK_Sig_Type_v1;
enum (disabled(0), enabled(1)} TACK_Activation;

struct {
   TACK_Version version;
   opaque public_key[64];
} TACK_Key;  /* 65 bytes */

struct {
   TACK_Sig_Type_v1 type;
   uint8  min_generation;
   uint8  generation;
   uint32 expiration;
   opaque target_sha256[32];
   opaque signature[64];
} TACK_Sig;  /* 103 bytes */

struct {
   TACK_Key key;
   TACK_Sig sig;
} TACK;  /* 168 bytes */

struct {
   TACK_Key key;
   opaque signature[64];   
} TACK_Break_Sig;  /* 129 bytes */

struct {
   TACK tacks&lt;0...1024&gt;  /* 0 or more TACKs */
   TACK_Break_Sig  break_sigs&lt;0...2048&gt;  /* 0 or more Break Sigs */
   TACK_Activation pin_activation;
} TACK_Extension;	
</artwork></figure>
</section>
<section title="Explanation of TACK_Extension fields">
	<section title="TACK_Key fields">
	<t>
	<list style="hanging">
	<t hangText="version:">

This field provides a version number which controls the interpretation of TACK
and TACK_Break_Sig. A client who does not recognize a TACK or TACK_Break_Sig's
version (which is the first byte of each) MUST NOT process the TACK or
TACK_Break_Sig.

	</t>
	<t hangText="public_key:">

This field specifies the server's "TACK public key". The field contains a pair
of integers (x, y) representing a point on the elliptic curve P-256 defined in
<xref target="FIPS186-3"/>. Each integer is encoded as a 32-byte octet string
using the Integer-to-Octet-String algorithm from <xref target="RFC6090"/>, and
these strings are concatenated with the x value first. (NOTE: This is
equivalent to an uncompressed subjectPublicKey from <xref target="RFC5480"/>,
except that the initial 0x04 byte is omitted).

	</t>	
 </list> 
</t>
</section> 

<section title="TACK_Sig fields">
<t>
<list style="hanging">

<t hangText="type:">

This field provides a type number which controls the interpretation of
TACK_Sig. A client who does not recognize a TACK_Sig.type MUST NOT process the
TACK_Sig.

</t>
<t hangText="min_generation:"> 

This field publishes a min_generation value.

</t>

<t hangText="generation:"> 

This field assigns each TACK a generation. Generations less than a published
min_generation are considered revoked.

</t>

<t hangText="expiration:"> 

This field specifies a time after which the TACK signature is considered
expired. The expiration time is encoded as the number of minutes, excluding
leap seconds, after midnight UTC, January 1, 1970. Equivalently, this field
multiplied by 60 equals the "UNIX time" encoding of the expiration time. </t>

<t hangText="target_sha256:"> 

This field is a hash of the TLS server's SubjectPublicKeyInfo <xref
target="RFC5280"/> using the SHA256 algorithm from <xref target="FIPS180-2"/>.
The SubjectPublicKeyInfo is typically conveyed as part of the server's X.509
certificate.

</t>

<t hangText="signature:">

This field is an ECDSA signature by the TACK's public key over the entire TACK
structure prior to the "signature" field (i.e. the preceding 104 bytes). The
field contains a pair of integers (r, s) representing an ECDSA signature as
defined in <xref target="FIPS186-3"/>, using curve P-256 and SHA256. Each
integer is encoded as a 32-byte octet string using the Integer-to-Octet-String
algorithm from <xref target="RFC6090"/>, and these strings are concatenated
with the r value first.

</t>
</list>
</t>
</section>


<section title="TACK fields">
<t>
<list style="hanging">

<t hangText="key:">

This field specifies the TACK's key.

</t>

<t hangText="sig:">

This field specifies the TACK's signature and related fields.

</t>
</list>
</t>
</section>


<section title="TACK_Break_Sig fields">
<t>
<list style="hanging">

<t hangText="key:">

This field specifies the TACK key being broken, and supplies the public key
used to verify the following signature.

</t>

<t hangText="signature:">

This field is an ECDSA signature by the TACK_Break_Sig's public key over the
entire TACK_Break_Sig structure prior to the "signature" field (i.e. the
preceding 65 bytes of TACK_Key), followed by the single byte 0x02
(representing the value "v1_break" from TACK_Sig_Type_v1). The field contains
a pair of integers (r, s) representing an ECDSA signature as defined in <xref
target="FIPS186-3"/>, using curve P-256 and SHA256. It is calculated and
encoded as per TACK_Sig.signature.

</t>


</list>
</t>
</section>

<section title="TACK_Extension fields">
<t>
<list style="hanging">

<t hangText="tacks:">

This field provides the server's TACK(s). It MAY be empty, or may contain
however many TACKs fit into 1 KB. If there are multiple TACKs, each TACK MUST
have a different version number, and the TACKs MUST be ordered with the lowest
version first, so that a client can stop processing this field once a
supported version is encountered. TACKs defined in this specification (with
version == v1) are always 168 byte in length. Version values defined in other
specifications MAY specify larger TACKs.

</t>

<t hangText="break_sigs:">

This field provides break signatures. It MAY be empty, or MAY contain however
many break signatures fit into 2 KB. The break signatures MAY have different
version values. In this case, the break signatures SHALL be ordered with the
lowest versions first, so that a client can stop processing this field once an
unrecognized version is encountered.

</t>
<t hangText="pin_activation:">

If this field is "enabled", this TACK_Extension MAY be used by clients to
activate or extend the activation of TACK pins. This field is typically
toggled from a disabled to an enabled state once TACKs have been deployed to
all TLS servers for a hostname.

</t> </list> </t>

<t> Note that both the "tacks" and "break_sigs" fields MAY be empty. </t>

</section>

</section> 
</section>

<section title="Client processing">
<section title="TACK pins, key records, and host records">

<t>

A client supporting TACK SHALL have a local store of pins, consisting of "key
records" and "host records". Each host record is associated with a key record.
Multiple host records may be associated with a single key record. A "pin"
refers to a (host record, key record) pair. Different pins can share the same
key record.

</t> 
<t>

 A "key record" contains:

<list style="empty">
<t>

TACK_Key (or hash): A TACK_Key or a cryptographically-secure, second
preimage-resistant hash of a TACK_Key. A key record "matches" a TACK or break
signature if the key record contains the structure's TACK_Key or its hash. A
client SHALL NOT store multiple key records for the same TACK_Key.

</t> 
<t>

Min_generation: A single byte used to detect revoked TACKs.

</t>
</list>
</t>
<t>

A "host record" contains:

<list style="empty">

<t>

Hostname: A DNS hostname. A client SHALL NOT store multiple host records with
the same hostname. A pin containing the current TLS connection's hostname is a
"relevant" pin.

</t>
<t>

Initial timestamp: A timestamp noting when this pin was created.

</t> 

<t>

Active period end: Empty or a timestamp. If empty or set to a time in the
past, the pin is "inactive". If set to a future time, the pin is "active"
until that time.

</t> 

</list>
</t>
</section>

<section title="High-level client processing">

<t>

A TLS client compliant with this specification SHALL send the "tack" extension
defined previously, as well as the "server_name" extension from <xref
target="RFC6066"/> indicating the hostname the client is contacting.

</t>
<t>

If not resuming a session, the server MAY respond with a TACK_Extension. If
so, the TLS client SHALL perform the following steps prior to using the TLS
connection:

<list style="numbers">
 <t>Discard pins based on break signatures (if present).</t>
 <t>Check for a valid TACK.</t>
 <t>Update and activate pins based on the valid TACK (if present).</t> 
</list>
</t>

<t>

If, after the above steps, there is a relevant active pin and a valid matching
TACK, then the connection is verified by the pin. If there is a relevant
active pin but no such TACK, the connection is rejected by the pin. How these
different cases affect client behavior is out of scope of this specification.

 </t> <t>


</t>

</section>
<section title="Client processing details"> 

<section title="Discarding pins based on break signatures"> 
<t>

All key records broken by break signatures SHALL be discarded, along with
their associated host records. A key record is broken by a break signature if
the following statements are true:

<list style="numbers">

	<t>The break signature's version field is recognized.</t>

 	<t>The break signature "matches" the key record.</t>

	<t>The break signature's "signature" field is a correct ECDSA signature over
the break signature's contents when verified using the break signature's
public key. </t>

</list>
</t> 
</section>

<section title="Checking for a valid TACK"> 
<t> 

A v1 TACK is "valid" if the below checks are true. (Checking the validity of
other TACK versions is not defined in this specification).

<list style="numbers">

 <t>The version and TACK_Sig.type fields are recognized.</t>

 <t>The TACK_Sig.generation is >= TACK_Sig.min_generation.</t>

 <t>The TACK_Sig.expiration is non-expired.</t>

 <t>The TACK_Sig.target_sha256 is equal to the SHA256 hash of the server's
   SubjectPublicKeyInfo.</t>

 <t>The TACK_Sig.signature is a correct ECDSA signature over the TACK's
contents when verified using the TACK's public key.</t>

 <t>The TACK_Sig.generation is >= the min_generation of any key record in 
	the client's store which matches the TACK.
	</t>	

 <t>The TLS handshake completes successfully.</t>

</list>
<vspace blankLines="100" />	

</t>
</section> 


<section title="Updating and activating pins based on the TACK"> 
<t>

A valid TACK is used to update the client's pin store. If there is a key
record matching the TACK, the key record's min_generation SHALL be set to the
TACK's min_generation if the TACK's value is larger.

</t>
<t>

A valid TACK MAY also be used to modify the host records using the "pin
activation" process described below. Note that the following steps are
optional; a client MAY rely on an external source of pins.

</t>
<t>

If there is a relevant pin matching the TACK, and the TACK Extension's
"pin_activation" is enabled, the host record's "active period end" MAY be set
according to the following formula (where "current" is the current time, and
"initial" is the "initial timestamp" from the host record):

</t> <figure><artwork>
active_period_end = current + MIN(30 days, current - initial)
</artwork></figure>	
<t>

If there is no relevant pin, or only an inactive one which does not match the
TACK, a new pin MAY be created with the following steps:
<list style="numbers">
<t>If the TACK's key matches an existing
key record, the key record is reused, otherwise a new key record is created
with the TACK's key and min_generation.</t>
<t>A new host record is created
containing the server's hostname, an "initial timestamp" equal to the current
time, and an empty "active period end".</t>	
<t>If there was an existing relevant host record, it is discarded.</t>
</list>
</t>
<t>

The following table summarizes this behavior based on whether the relevant pin
is active and matches the TACK. The "(*)" means "if
TACK_Extension.pin_activation is enabled".

</t>
      <texttable>
           <ttcol align='left'>Pin status</ttcol>
           <ttcol align='left'>TACK matches pin?</ttcol>
           <ttcol align='left'>Result</ttcol>
           <c>Active</c>
           <c>Yes</c>
           <c>Extend activation period (*)</c>

           <c>Active</c>
           <c>No</c>
           <c>Rejected</c>

           <c>Inactive</c>
           <c>Yes</c>
           <c>Activate pin (*)</c>

           <c>Inactive</c>
           <c>No</c>
           <c>Replace with new inactive pin</c>

           <c>None</c>
           <c>-</c>
           <c>Create new inactive pin</c>
       </texttable>

</section>
</section>	
</section>

<section title="TACK IDs">	
<t>
A "TACK ID" MAY be used to represent a TACK_Key to users. A TACK ID is an
encoded string of 125 bits, containing first the 5 bits TACK ID version
(=0x01) followed by the first 120 bits of SHA256(TACK_Key).
</t>

<t>

Each of the 25 5-bit values in the TACK ID is encoded into a character by
representing the value as a number from 0-31, then choosing the appropriate
character from the below alphabet (where 0 is 'a', 1 is 'b', ..., 31 is '9').
The 25 encoded characters are then split into five groups of five characters,
separated by periods.

</t>
<t>

The TACK ID alphabet is "abcdefghijkLmnpqrstuvwxy13456789". The alphabet is
constructed by taking the uppercase letters followed by numbers, with the
visually similar character pairs (0, O) and (2, z) omitted, and the visually
similar pair ("1", "l") disambiguated by capitalizing the letter "L".

</t>
<t>
Example TACK IDs:	
</t>
<t>
<list>
	<t>bkihj.gu49L.Lk4ap.6vmxj.88kaL</t>
	<t>b3v8i.Ltauw.13vk8.h69fy.rsqqt</t>
	<t>bsspt.aecek.u596t.39h8x.LL31L</t>	
</list>
</t>

</section>

<section title="Advice"> 
<section title="For server operators">
<t>
<list style="hanging">

<t hangText="Key reuse:">

All servers that are pinned to a single key are able to impersonate each
other. Thus, different keys should be used to pin hostnames with different
security properties.

</t>

<t hangText="Generations:">

To revoke older generations of TACKs, the server operator should first provide
all servers with a new generation of TACKs, then provide servers with new
TACKs containing the new min_generation. This is safer then trying to update
min_generation and generation simultaneously across a range of servers, since
a client may receive a min_generation update from one server but then try to
contact a server which has not yet been updated, and still has an
older-generation TACK.</t>

<t hangText="Signature expiration:">

It is convenient to set the TACK signature expiration equal to the end-entity
certificate expiration, so that the TACK and certificate may both be replaced
at the same time. Alternatively, short-lived TACK signatures may be used so
that a compromised TLS private key has limited value to an attacker.</t>

<t hangText="Break signatures:">

Break signatures are useful if a server wishes to abruptly change its TACK
key, stop using TACKs, or advertise that a TACK key is compromised and clients
should stop relying on it. A break signature only needs to be published for a
time interval equal to the maximum active period of any affected pins. For
example, if a TACK has been only been published on a website for 24 hours,
removing the TACK requires only publishing the break signature for 24 hours.

</t>
<t hangText="Pin activation:">

The pin_activation field should only be toggled to "enabled" once all TLS
servers sharing the same hostname have a valid TACK. Otherwise, a client may
activate a pin by contacting one server, then contact a different server at
the same hostname that does not yet have a valid TACK. The pin_activation
field can also be used to phase out use of TACKs for a hostname - if all
servers at a hostname disable pin activation, existing pins will eventually
all become deactivated (within 30 days at most).

</t>


</list>
<vspace blankLines="100" />	
</t>
</section> 
<section title="For client implementors">
<t>
<list style="hanging">
<t hangText="Sharing pin information:">

It is possible for a client to maintain a pin store based entirely on its own
TLS connections. However, such a client runs the risk of creating incorrect
pins, failing to keep its pins active, or failing to receive revocation
information (min_generation updates and break signatures). Clients are advised
to collaborate so that pin data can be aggregated and shared. This will likely
require additional protocols and infrastructure outside the scope of this
document.

</t>

</list>
</t>
</section> 
</section>

        <section title="Security considerations">
        <t>
All servers sharing a TACK key can impersonate each other.
Use different TACK keys for servers with different security properties.
</t>
<t>

Make backup copies of the TACK private key and keep all copies in secure
locations where they can't be compromised.

</t>
<t>

A TACK private key MUST NOT be used to perform any non-TACK cryptographic
operations. For example, using a TACK elliptic curve key for email encryption,
code-signing, or any other purpose MUST NOT be done.

</t> <t>

HTTP cookies <xref target="RFC6265"/> set by a pinned host can be stolen by a
network attacker who can forge web and DNS responses so as to cause a client
to send the cookies to a phony subdomain of the pinned host. To prevent this,
TACK HTTPS Servers SHOULD set the "secure" attribute and omit the "domain"
attribute on all security-sensitive cookies, such as session cookies. These
attribute settings tell the browser that the cookie should only be presented
back to the originating host (not its subdomains), and should only be sent
over HTTPS (not HTTP) <xref target="RFC6265"/>.

</t>

        </section>

	<section title="IANA considerations">
	<section title="New entry for the TLS ExtensionType Registry">
	<t>

IANA is requested to add an entry to the existing TLS ExtensionType registry,
defined in RFC 5246, for tack(TBD) as defined in this document.

 </t>
</section>
	<section title="New registries for TACK_Version and TACK_Sig_Type_v1">
	<t>

IANA is requested to establish new registries for TLS TACK_Version and TLS
TACK_Sig_Type_v1 values. The initial entries in TACK_Version are 0(reserved),
and 1(v1). The initial entries in TACK_Sig_Type_v1 are 0(reserved),
1(v1_spki), and 2(v1_break). The policy for adding new values to these
registries, following the terminology defined in <xref target="RFC5226"/>, is
Expert Review.

	</t>
	<t>

The designated expert is expected to consult the TLS mailing list or its
designated successor, as well as review any documentation to determine whether
the extension will be widely useful and is fully documented. To preserve the
limited number of code points and maximize interoperability, the presumption
should be that a code point SHOULD NOT be granted, unless there is a
compelling reason to the contrary.

 </t>

 </section>
</section>
<section title="Acknowledgements">
<t>

Valuable feedback has been provided by Adam Langley, Chris Palmer, Nate
Lawson, and Joseph Bonneau.

</t> </section>

    </middle>

    <back>
        <references title='Normative references'>
	
<reference
  anchor="FIPS180-2"
  target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">
  <front>
    <title>Secure Hash Standard</title>
    <author>
      <organization>National Institute of Standards and Technology</organization>
    </author>
    <date month="August" year="2002" />
  </front>
  <seriesInfo name="FIPS" value="PUB 180-2" />
</reference>

<reference 
	anchor="FIPS186-3" 
	target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">
<front>
<title>Digital Signature Standard</title>
<author>
<organization>National Institute of Standards and Technology</organization>
</author>
<date month="June" year="2009" />
</front>
<seriesInfo name="FIPS" value="PUB 186-3" />
</reference>

			<?rfc include="bib/reference.RFC.2119.xml"?>
			<?rfc include="bib/reference.RFC.5226.xml"?>
			<?rfc include="bib/reference.RFC.5246.xml"?>
			<?rfc include="bib/reference.RFC.5280.xml"?>			
			<?rfc include="bib/reference.RFC.5480.xml"?>
			<?rfc include="bib/reference.RFC.6066.xml"?>			
			<?rfc include="bib/reference.RFC.6090.xml"?>			
			<?rfc include="bib/reference.RFC.6265.xml"?>
	</references>
    </back>

</rfc>
