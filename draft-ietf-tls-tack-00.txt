


TLS Working Group                                         M. Marlinspike
Internet-Draft                                            T. Perrin, Ed.
Intended status: Standards Track                          March 20, 2012
Expires: September 21, 2012


                 Trust Assertions for Certificate Keys
                       draft-ietf-tls-tack-00.txt

Abstract

   This document defines TACK, a TLS Extension that enables a TLS server
   to assert the authenticity of its public key.  A TACK contains a
   "TACK signing key" and a "TACK signature" from that key over the TLS
   server's public key.  Hostnames can be "pinned" to a TACK key.  TLS
   connections to a pinnned hostname are only considered verified if the
   server presents a TACK containing the pinned TACK key and a valid
   TACK signature.

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on September 21, 2012.

Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of



Marlinspike & Perrin   Expires September 21, 2012               [Page 1]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Requirements notation  . . . . . . . . . . . . . . . . . . . .  4
   3.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
     3.1.  TACK life cycle  . . . . . . . . . . . . . . . . . . . . .  5
     3.2.  Pin life cycle . . . . . . . . . . . . . . . . . . . . . .  6
   4.  TACK Extension . . . . . . . . . . . . . . . . . . . . . . . .  7
     4.1.  Definition of TACK_Extension . . . . . . . . . . . . . . .  7
     4.2.  Explanation of TACK_Extension fields . . . . . . . . . . .  8
       4.2.1.  TACK_Key fields  . . . . . . . . . . . . . . . . . . .  8
       4.2.2.  TACK_Sig fields  . . . . . . . . . . . . . . . . . . .  8
       4.2.3.  TACK fields  . . . . . . . . . . . . . . . . . . . . .  9
       4.2.4.  TACK_Break_Sig fields  . . . . . . . . . . . . . . . .  9
       4.2.5.  TACK_Extension fields  . . . . . . . . . . . . . . . .  9
   5.  Client processing  . . . . . . . . . . . . . . . . . . . . . . 10
     5.1.  TACK pins, key records, and host records . . . . . . . . . 10
     5.2.  High-level client processing . . . . . . . . . . . . . . . 10
     5.3.  Client processing details  . . . . . . . . . . . . . . . . 11
       5.3.1.  Discarding pins based on break signatures  . . . . . . 11
       5.3.2.  Checking whether the TACK is valid . . . . . . . . . . 11
       5.3.3.  Updating and activating pins based on the TACK . . . . 12
   6.  Miscellaneous  . . . . . . . . . . . . . . . . . . . . . . . . 13
     6.1.  TACK IDs . . . . . . . . . . . . . . . . . . . . . . . . . 13
     6.2.  Cookies and TACKs  . . . . . . . . . . . . . . . . . . . . 13
   7.  Advice . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
     7.1.  For server operators . . . . . . . . . . . . . . . . . . . 14
     7.2.  For client implementors  . . . . . . . . . . . . . . . . . 15
   8.  Security considerations  . . . . . . . . . . . . . . . . . . . 16
   9.  IANA considerations  . . . . . . . . . . . . . . . . . . . . . 17
     9.1.  New entry for the TLS ExtensionType Registry . . . . . . . 17
     9.2.  New registries for TACK_Key_Type and TACK_Sig_Type . . . . 17
   10. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 18
   11. Normative references . . . . . . . . . . . . . . . . . . . . . 19
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 20












Marlinspike & Perrin   Expires September 21, 2012               [Page 2]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


1.  Introduction

   Traditionally, a TLS client verifies a TLS server's public key using
   a certificate chain issued by some public CA.  TACK facilitates
   stronger methods of verifying server public keys.

   One such method is for clients to employ "pinning", in which the
   client uses past connections to verify future connections by checking
   for some constant element.  Unfortunately, a number of problems arise
   when attempting to pin certificate chains: the TLS servers at a given
   hostname may have different certificate chains, and may change their
   chains at any time; the "more constant" elements of a chain - the CAs
   - may not be trustworthy; and the client employing pinning may be
   oblivious to key compromise events which render the pinned data
   untrustworthy.

   TACK addresses these problems by having the site choose a TACK
   signing key which is used to sign TLS server public keys.  This
   enables clients to "pin" a hostname to the TACK key without requiring
   sites to modify their existing certificate chains, and without
   limiting a site's flexibility to deploy different certificate chains
   on different servers, or change certificate chains at any time.
   Since TACK pins are based on TACK keys (instead of CA keys), trust in
   CAs is not required.  Additionally, the TACK key may be used to
   revoke previous TACK signatures or even itself, to handle compromise
   of TLS or TACK private keys.

   If requested by a client, a compliant server will send a TLS
   Extension containing its "TACK".  Inside the TACK is a TACK public
   key and TACK signature.  Once a client has seen the same (hostname,
   TACK public key) pair multiple times, the client will "activate" a
   pin between the hostname and TACK key for a period equal to the
   length of time the pair has been observed for.  This "pin activation"
   process limits the impact of bad pins resulting from transient
   network attacks or operator error.

   TACK pins are easily communicated between clients.  For example, a
   TACK client may scan the internet to discover TACK pins, then publish
   these pins for other clients to rely upon.












Marlinspike & Perrin   Expires September 21, 2012               [Page 3]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


2.  Requirements notation

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].














































Marlinspike & Perrin   Expires September 21, 2012               [Page 4]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


3.  Overview

3.1.  TACK life cycle

   A server operator using TACK may perform several processes:

   Selection of a TACK key:  The server operator first chooses the ECDSA
      signing key to use for a set of hostnames.

   Creating initial TACKs under a TACK key:  The TACK private key is
      then used to sign the TLS public keys for all servers associated
      with those hostnames.  The TACK public key and signature are
      combined with some metadata into each server's "TACK".

   Creating new TACKs under a TACK key:  A TACK must be replaced
      whenever a server changes its TLS public key, or when a TACK
      signature expires.  TACKs may also need to be replaced with later-
      generation TACKs if the TACK key's "min_generation" is updated
      (see next).

   Revoking old TACKs:  If a TLS private key is compromised, the
      affected TACKs can be revoked by publishing a new TACK containing
      a higher "min_generation".

   Revoking TACK keys:  If a TACK private key is compromised, or a
      server operator wishes to stop using TACK for any reason, a server
      can revoke an entire TACK key (including all TACKs and pins
      referring to it) by publishing a "break signature".























Marlinspike & Perrin   Expires September 21, 2012               [Page 5]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


3.2.  Pin life cycle

   A TACK client maintains a store of pins for verifying TLS
   connections.  Pins associate a hostname and a TACK key.  When a
   client sees a new hostname and TACK key combination, an inactive pin
   is created.  Once the client has seen the pin more than once, the pin
   is "activated" for a period equal to the timespan between the first
   time the pin was seen and the most recent time, or a maximum period
   of 30 days.

   Pin activation serves multiple purposes.  First, it prevents an
   attacker with short-lived control of the hostname from setting long-
   lived pins.  Second, it makes it safer for sites to experiment with
   TACKs, as a new TACK can be discarded without causing long-lived
   problems.  The 30 day limit on activation period guarantees that a
   worst-case pin can be recovered from in reasonable time.

   In addition to creating and activating pins, a TLS connection can
   alter the clients's pin store in two other ways:

   Min_generation:  Each pin stores the highest "min_generation" value
      it has seen from the pinned TACK key, and rejects TACKs from
      earlier generations.

   Break signatures:  A TLS handshake may send break signatures which
      cause all pins for the broken key to be discarded.

























Marlinspike & Perrin   Expires September 21, 2012               [Page 6]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


4.  TACK Extension

4.1.  Definition of TACK_Extension

   A new TLS ExtensionType ("tack") is defined and MAY be included by a
   TLS client in the client hello message defined in [RFC5246].

   enum {tack(TBD), (65535)} ExtensionType;

   The "extension_data" field of this extension SHALL be empty.  A TLS
   server which is not resuming a TLS session MAY respond with an
   extension of type "tack" in the server hello message defined in
   [RFC5246].  The "extension_data" field of this extension SHALL
   contain a "TACK_Extension", as defined below using the TLS
   presentation language from [RFC5246].

   enum {v1(1)} TACK_Key_Type;
   enum {v1(1)} TACK_Sig_Type;

   struct {
      TACK_Key_Type type;
      opaque public_key[64];
   } TACK_Key;  /* 65 bytes */

   struct {
      TACK_Sig_Type type;
      uint8  min_generation;
      uint8  generation;
      uint32 expiration;
      opaque target_sha256[32];
      opaque signature[64];
   } TACK_Sig;  /* 103 bytes */

   struct {
      TACK_Key key;
      TACK_Sig sig;
   } TACK;  /* 168 bytes */

   struct {
      TACK_Key key;
      opaque signature[64];
   } TACK_Break_Sig;  /* 129 bytes */

   struct {
      TACK tack<0...1024>   /* 0 or 1 TACKs */
      TACK_Break_Sig break_sigs<0...2048>   /* 0 or more Break Sigs */
   } TACK_Extension;




Marlinspike & Perrin   Expires September 21, 2012               [Page 7]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


4.2.  Explanation of TACK_Extension fields

4.2.1.  TACK_Key fields

   type:  This field provides a version number which controls the
      interpretation of TACK and TACK_Break_Sig. A client who does not
      recognize a TACK or TACK_Break_Sig's TACK_Key.type MUST NOT
      process the TACK or TACK_Break_Sig.

   public_key:  This field specifies the server's "TACK public key".
      The field contains a pair of integers (x, y) representing a point
      on the elliptic curve P-256 defined in [FIPS186-3].  Each integer
      is encoded as a 32-byte octet string using the Integer-to-Octet-
      String algorithm from [RFC6090], and these strings are
      concatenated with the x value first.  (NOTE: This is equivalent to
      an uncompressed subjectPublicKey from [RFC5480], except that the
      initial 0x04 byte is omitted).

4.2.2.  TACK_Sig fields

   type:  This field provides a version number which controls the
      interpretation of TACK_Sig. A client who does not recognize a
      TACK_Sig.type MUST NOT process the TACK_Sig.

   min_generation:  This field publishes a min_generation value.

   generation:  This field assigns each TACK a generation.  Generations
      less than a published min_generation are considered revoked.

   expiration:  This field specifies a time after which the TACK
      signature is considered expired.  The expiration time is encoded
      as the number of minutes, excluding leap seconds, after midnight
      UTC, January 1, 1970.  Equivalently, this field multiplied by 60
      equals the "UNIX time" encoding of the expiration time.

   target_sha256:  This field is a hash of the TLS server's
      SubjectPublicKeyInfo [RFC5280] using the SHA256 algorithm from
      [FIPS180-2].  The SubjectPublicKeyInfo is typically conveyed as
      part of the server's X.509 certificate.

   signature:  This field is an ECDSA signature by the TACK's public key
      over the entire TACK structure prior to the "signature" field
      (i.e. the preceding 104 bytes).  The field contains a pair of
      integers (r, s) representing an ECDSA signature as defined in
      [FIPS186-3], using curve P-256 and SHA256.  Each integer is
      encoded as a 32-byte octet string using the Integer-to-Octet-
      String algorithm from [RFC6090], and these strings are
      concatenated with the r value first.



Marlinspike & Perrin   Expires September 21, 2012               [Page 8]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


4.2.3.  TACK fields

   key:  This field specifies the TACK's key.

   sig:  This field specifies the TACK's signature and related fields.

4.2.4.  TACK_Break_Sig fields

   key:  This field specifies the TACK key being broken, and supplies
      the public key used to verify the following signature.

   signature:  This field is an ECDSA signature by the TACK_Break_Sig's
      public key over the entire TACK_Break_Sig structure prior to the
      "signature" field (i.e. the preceding 65 bytes of TACK_Key).  It
      is calculated and encoded as per TACK_Sig.signature.

4.2.5.  TACK_Extension fields

   tack:  This field provides the server's TACK, if any.

   break_sigs:  This field provides break signatures.  It MAY be empty,
      or MAY contain however many break signatures fit into 2 KB.  The
      break signatures MAY have different TACK_Key.type values.  In this
      case, the break signatures SHALL be ordered with the lowest types
      first, so that a client can stop processing this field once an
      unrecognized TACK_Key.type is encountered.

   Note that both the "tack" and "break_sigs" fields MAY be empty.























Marlinspike & Perrin   Expires September 21, 2012               [Page 9]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


5.  Client processing

5.1.  TACK pins, key records, and host records

   A client supporting TACK SHALL have a local store of pins, consisting
   of "key records" and "host records".  Each host record is pinned to a
   key record.  Multiple host records may be pinned to a single key
   record.  A "pin" refers to a (host record, key record) pair.
   Different pins can share the same key record.

   A "key record" contains:

      TACK_Key (or hash): A TACK_Key or a cryptographically-secure,
      second preimage-resistant hash of a TACK_Key. A key record
      "matches" a TACK or break signature if the key record contains the
      structure's TACK_Key or its hash.  A client SHALL NOT store
      multiple key records for the same TACK_Key.

      Min_generation: A single byte used to detect revoked TACKs.

   A "host record" contains:

      Hostname: A DNS hostname.  A client SHALL NOT store multiple host
      records with the same hostname.  A pin containing the current TLS
      connection's hostname is a "relevant" pin.

      Initial timestamp: A timestamp noting when this pin was created.

      Active period end: Empty or a timestamp.  If empty or set to a
      time in the past, the pin is "inactive".  If set to a future time,
      the pin is "active" until that time.

5.2.  High-level client processing

   A TLS client compliant with this specification SHALL send the "tack"
   extension defined previously, as well as a "server_name" extension
   indicating the hostname the client is contacting.

   If not resuming a session, the server MAY respond with a
   TACK_Extension.  If so, the TLS client SHALL perform the following
   steps prior to using the TLS connection:

   1.  Discard pins based on break signatures (if present).

   2.  Check whether the TACK is valid (if present).

   3.  Update and activate pins based on the TACK (if valid).




Marlinspike & Perrin   Expires September 21, 2012              [Page 10]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


   If a TLS session that had a valid TACK is being resumed, step 1 above
   is skipped and the session's TACK is used for steps 2 and 3.

   If, after the above steps, there is a relevant active pin and a valid
   matching TACK, then the connection is verified by the pin.  If there
   is a relevant active pin but no such TACK, the connection is rejected
   by the pin.  If there is no relevant active pin, the connection is
   unverified by a pin.  How these different cases affect client
   behavior is out of scope of this specification.

5.3.  Client processing details

5.3.1.  Discarding pins based on break signatures

   All key records broken by break signatures SHALL be discarded, along
   with their associated host records.  A key record is broken by a
   break signature if the following statements are true:

   1.  The break signature's TACK_Key.type field is recognized.

   2.  The break signature "matches" the key record.

   3.  The break signature's "signature" field is a correct ECDSA
       signature over the break signature's contents when verified using
       the break signature's public key.

5.3.2.  Checking whether the TACK is valid

   A TACK is "valid" if the following checks are true:

   1.  The TACK_Key.type and TACK_Sig.type fields are recognized.

   2.  The TACK_Sig.generation is >= TACK_Sig.min_generation.

   3.  The TACK_Sig.expiration is non-expired.

   4.  The TACK_Sig.target_sha256 is equal to the SHA256 hash of the
       server's SubjectPublicKeyInfo (or a session is being resumed).

   5.  The TACK_Sig.signature is a correct ECDSA signature over the
       TACK's contents when verified using the TACK's public key.

   6.  The TACK_Sig.generation is >= the min_generation of any key
       record in the client's store which matches the TACK.

   7.  The TLS handshake completes successfully.





Marlinspike & Perrin   Expires September 21, 2012              [Page 11]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


5.3.3.  Updating and activating pins based on the TACK

   A valid TACK is used to update the client's pin store.  If there is a
   key record matching the TACK, the key record's min_generation SHALL
   be set to the TACK's min_generation if the TACK's value is larger.

   A valid TACK MAY also be used to modify the host records using the
   "pin activation" process described below.  Note that the following
   steps are optional; a client MAY rely on an external source of pins.

   If there is a relevant pin matching the TACK, the host record's
   "active period end" MAY be set according to the following formula
   (where "current" is the current time, and "initial" is the "initial
   timestamp" from the host record):


   active_period_end = current + MIN(30 days, current - initial)


   If there is no relevant pin, or only an inactive one which does not
   match the TACK, a new pin MAY be created with the following steps:

   1.  If the TACK's key matches an existing key record, the key record
       is reused, otherwise a new key record is created with the TACK's
       key and min_generation.

   2.  A new host record is created containing the server's hostname, an
       "initial timestamp" equal to the current time, and an empty
       "active period end".

   3.  If there was an existing relevant host record, it is discarded.

   The following table summarizes this behavior based on whether the
   relevant pin is active and matches the TACK:

    +------------+-------------------+-------------------------------+
    | Pin status | TACK matches pin? | Result                        |
    +------------+-------------------+-------------------------------+
    | Active     | Yes               | Extend activation period      |
    |            |                   |                               |
    | Active     | No                | Rejected                      |
    |            |                   |                               |
    | Inactive   | Yes               | Activate pin                  |
    |            |                   |                               |
    | Inactive   | No                | Replace with new inactive pin |
    |            |                   |                               |
    | None       | -                 | Create new inactive pin       |
    +------------+-------------------+-------------------------------+



Marlinspike & Perrin   Expires September 21, 2012              [Page 12]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


6.  Miscellaneous

6.1.  TACK IDs

   A "TACK ID" MAY be used to represent a TACK_Key to users.  A TACK ID
   is a base32 encoding of 5 bits TACK ID version (=0x01) followed by
   the first 120 bits of SHA256(TACK_Key).  The base32 alphabet used is
   "ABCDEFGHIJKLMNPQRSTUVWXY13456789" (in other words: uppercase letters
   followed by numbers, with the visually similar character pairs (0, O)
   and (2, Z) omitted).  Example TACK IDs:

      BJFVI.U5YFA.WXMIW.CQGFW.APVIF

      B3LBX.KWYAP.A8CT1.4IFE8.JDQPT

      BUT93.HCELT.SU745.LA44H.WJFGF

6.2.  Cookies and TACKs

   HTTP cookies with a "secure" atttribute (aka "secure cookies")
   [RFC6265] set over a TLS connection with a valid TACK SHALL be bound
   to the TACK's TACK_Key. Clients SHALL only send these cookies over
   TLS connections with a valid TACK containing the same TACK_Key.

   Note that the decisions to bind a cookie received over a TLS
   connection to a TACK_Key, and to send such a cookie over a TLS
   connection, do not take into account whether the TLS connections are
   verified by a pin, rejected by a pin, or unverified by a pin.























Marlinspike & Perrin   Expires September 21, 2012              [Page 13]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


7.  Advice

7.1.  For server operators

   Key reuse:  All servers that are pinned to a single key are able to
      impersonate each other.  Thus, different keys should be used to
      pin hostnames with different security properties.  However, all
      servers sharing secure cookies must be pinned to the same key.
      Due to cookie scoping rules (see [RFC6265]), it will often be
      desirable to pin web servers under a single DNS domain to a single
      key.

   Generations:  To revoke older generations of TACKs, the server
      operator should first provide all servers with a new generation of
      TACKs, then provide servers with new TACKs containing the new
      min_generation.  This is safer then trying to update
      min_generation and generation simultaneously across a range of
      servers, since a client may receive a min_generation update from
      one server but then try to contact a server which has not yet been
      updated, and still has an older-generation TACK.

   Signature expiration:  It is convenient to set the TACK signature
      expiration equal to the end-entity certificate expiration, so that
      the TACK and certificate may both be replaced at the same time.
      Alternatively, short-lived TACK signatures may be used so that a
      compromised TLS private key has limited value to an attacker.

   Break signatures:  Break signatures are useful if a server wishes to
      abruptly change its TACK key, stop using TACKs, or advertise that
      a TACK key is compromised and clients should stop relying on it.
      A break signature only needs to be published for a time interval
      equal to the maximum active period of any affected pins.  For
      example, if a TACK key has only been used for a TACK which has
      been published on a website for 24 hours, the break signature only
      needs to be published for 24 hours.
















Marlinspike & Perrin   Expires September 21, 2012              [Page 14]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


7.2.  For client implementors

   Sharing pin information:  It is possible for a client to maintain a
      pin store based entirely on its own TLS connections.  However,
      such a client runs the risk of creating incorrect pins, failing to
      keep its pins active, or failing to receive revocation information
      (min_generation updates and break signatures).  Clients are
      advised to collaborate so that pin data can be aggregated and
      shared.  This will likely require additional protocols and
      infrastructure outside the scope of this document.









































Marlinspike & Perrin   Expires September 21, 2012              [Page 15]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


8.  Security considerations

   All servers sharing a TACK key can impersonate each other.  Use
   different TACK keys for servers with different security properties.

   Make backup copies of the TACK private key and keep all copies in
   secure locations where they can't be compromised.












































Marlinspike & Perrin   Expires September 21, 2012              [Page 16]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


9.  IANA considerations

9.1.  New entry for the TLS ExtensionType Registry

   IANA is requested to add an entry to the existing TLS ExtensionType
   registry, defined in RFC 5246, for tack(TBD) as defined in this
   document.

9.2.  New registries for TACK_Key_Type and TACK_Sig_Type

   IANA is requested to establish new registries for TLS TACK_Key_Type
   and TLS TACK_Sig_Type values.  The initial entries in each registry
   are 0(reserved) and 1(v1).  The policy for adding new values to these
   registries, following the terminology defined in [RFC5226], is Expert
   Review.

   The designated expert is expected to consult the TLS mailing list or
   its designated successor, as well as review any documentation to
   determine whether the extension will be widely useful and is fully
   documented.  To preserve the limited number of code points and
   maximize interoperability, the presumption should be that a code
   point SHOULD NOT be granted, unless there is a compelling reason to
   the contrary.




























Marlinspike & Perrin   Expires September 21, 2012              [Page 17]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


10.  Acknowledgements

   Valuable feedback has been provided by Adam Langley, Chris Palmer,
   Nate Lawson, and Joseph Bonneau.















































Marlinspike & Perrin   Expires September 21, 2012              [Page 18]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


11.  Normative references

   [FIPS180-2]
              National Institute of Standards and Technology, "Secure
              Hash Standard", FIPS PUB 180-2, August 2002, <http://
              csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf>.

   [FIPS186-3]
              National Institute of Standards and Technology, "Digital
              Signature Standard", FIPS PUB 186-3, June 2009, <http://
              csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              May 2008.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008.

   [RFC5480]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Elliptic Curve Cryptography Subject Public Key
              Information", RFC 5480, March 2009.

   [RFC6090]  McGrew, D., Igoe, K., and M. Salter, "Fundamental Elliptic
              Curve Cryptography Algorithms", RFC 6090, February 2011.

   [RFC6265]  Barth, A., "HTTP State Management Mechanism", RFC 6265,
              April 2011.















Marlinspike & Perrin   Expires September 21, 2012              [Page 19]

Internet-Draft    Trust Assertions for Certificate Keys       March 2012


Authors' Addresses

   Moxie Marlinspike


   Trevor Perrin (editor)













































Marlinspike & Perrin   Expires September 21, 2012              [Page 20]

